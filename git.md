staged - поэтапный, инсценированный (в git состояние файла, которое инициируется командой 'git add' ля подготовки файла к коммиту)
stagina area - в git область подготовленных файлов


git help based on hexlet
git связывает все коммиты линейным списком
git init - создает репозиторий в текущем каталоге
git init --bare создает "пустой" репозиторий в текущем каталоге
git remote -v показывает где находится родительский репозиторий
git config --global user.name 'User Name' сконфигурировать git для использования от 'User Name'
git config --global user.email 'user@email.io' сконфигурировать git для использования от 'user@mail.io'
git add готовит(переводит в состояние tracked) добавленный или измененный файл к коммиту(созданию ревизии)
git rm удаляет файл из состояни 'tracked'
git commit -m 'comment' создает коммит с комментарием (ключ -m)
git reset  переводит файл из состояние 'staged' в 'modified'
git checkout -- path/to/file переводит файл из состояния modified в unmodified, то есть по сути эта команда сбрасывает изменения.
git checkout [commit_identificator] переключает рабочую копию в состояние от commit_identificator 
git branch показывает в какой ветке мы находимся
git branch [branch_name] создание новой ветки в репозитории 
git merge сливает ветки между собой -> результат слияния 'merge commit', который не содержит изменений. 
git merge [branch_name] выполняется из той ветки, в которую нам необходимо слить побочуню ветку, а а аргумент branch_name указывает какую ветку мы хотим слить
git push [rep_name] [branch_name] "запушить" перерадть изменения в родительский репозиторий с именем rep_name и именем ветки branch_name
git push --set-upstream [rep_name] [branch_name] задать отслеживаемую ветку branch_name в rep_name (устанавливает отслеживание и отправляет изменения)
git pull получить изменения из репозитория (для того, чтобы получить "прямую" историю коммитов следует использовать git pull --rebase) 
git fetch скачивает изменения из удаленного репозитория

Рабочий процесс

Добавляем или изменяем файлы и директории.
Подготавливаем новое содержимое к коммиту командой git add. Эту команду нужно применять даже в том случае, если файл был просто изменён.
Выполняем коммит.

Осмысленное именование коммита
Атомарность решения задачи в коде

.gitignore - файл для создания исключений для git (файлы не показываются даже командой git status)